public class ColaEnlazada<T> implements Cola<T> {
    private Nodo<T> frente;
    private Nodo<T> fin;
    private int tamano;
    
    public boolean esVacia() { return this.tamano == 0; }
    
    public void encolar(T elemento) {
        Nodo<T> nuevo = new Nodo<>(elemento);
        if (this.esVacia()) {
            this.frente = nuevo;
            this.fin = nuevo;
        } else {
           this.fin.setSiguiente(nuevo);  // Conectar nuevo al final actual
            this.fin = nuevo;  // Actualizar fin
        }
        this.tamano++;
    }
    
    public T desencolar() throws TADException {
        if (this.esVacia()) throw new TADException("Cola vacía");
        T resultado = this.frente.getInfo();  // Obtener info del frente
        this.frente = this.frente.getSiguiente();  // Actualizar frente al siguiente
        if (this.frente == null) this.fin = null;  // Si se vacía, actualizar fin
        this.tamano--;
        return resultado;
    }
}

public class PilaEstatica<T> implements Pila<T> {
    private T[] elementos;
    private int cima;  // Índice de la cima
    private static final int CAPACIDAD = 10;
    
    @SuppressWarnings("unchecked")
    public PilaEstatica() {
        this.elementos = (T[]) new Object[CAPACIDAD];
        this.cima = -1;
    }
    
    public boolean esVacia() { return this.cima == -1; }
    
    public void apilar(T elemento) throws TADException {
        if (this.cima == CAPACIDAD - 1) throw new TADException("Pila llena");
         this.cima++;
        this.elementos[this.cima] = elemento;  // Incrementar cima y asignar
       
    }
    
    public T desapilar() throws TADException {
        if (this.esVacia()) throw new TADException("Pila vacía");
        T resultado = this.elementos[this.cima];  // Obtener elemento en la nueva cima
        this.elementos[this.cima + 1] = null;  // Limpieza opcional
        this.cima--;
        return resultado;
    }
    
    public int tamano() { return this.cima + 1; }
}

4 8
5 9 
lista de Int


reversa :: [Int] -> [Int]

reversa [] = [] -- Caso base

reversa (x:xs) = reserva xs ++ [x]  -- Concatenar x al final de reversa xs





reversa [1,2,3]
= reversa[2,3] ++ [1]
= reversa [3] ++ [2] ++ [1]
= ((reversa [] ++ [3]) ++ [2]) ++ [1] -- caso base
= ([] ++ [3] ++ [2]) ++ [1]
= [3,2,1]


En Programación OO, ¿qué es el polimorfismo en Java y cómo se logra con sobrecarga de métodos versus sobrescritura? 
Proporciona un ejemplo breve (1 línea cada uno).

el polimorfismo es la capacidad de tratar a un objeto de diferentes tipos,
el cual no se especifica segun el contexto

la sobrecarca de metodos, es cuando se define multiples metodos dentro de una misma clase
que comparten el mismo nombre pero difieren en tipo o numero de parametros


la sobrescritura que dentro de java se puede ver com @Override permite que una 
subclase redefina un metodo de su clase padre, remplazando su comportamiento sin
cambiar su nombre

